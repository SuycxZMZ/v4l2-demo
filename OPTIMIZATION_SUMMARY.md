# 代码优化和格式说明总结

## 一、打印优化

### 问题
之前的代码每读取一帧就打印一次信息，导致屏幕快速刷屏，无法看清信息。

### 解决方案
1. **添加 `last_print_time` 字段**：在 `FrameStats` 结构中记录上次打印时间
2. **每秒打印一次**：使用 `difftime()` 检查时间间隔，只有超过 1 秒才打印
3. **使用 `\r` 原地更新**：使用 `\r` 和 `fflush()` 实现同一行更新，避免刷屏
4. **优化输出格式**：使用简洁的单行格式显示关键信息

### 效果
- 之前：每帧都打印，屏幕快速滚动
- 现在：每秒更新一次，同一行显示，清晰易读

### 输出示例
```
[1234 帧] FPS: 30.00 | 已保存: 5 | 尺寸: 640x480 | 格式: YUYV | 帧大小: 614400 字节
```

## 二、YUYV 格式详解

### 什么是 YUYV？

YUYV（也称为 YUY2 或 YUV 4:2:2）是一种**未压缩的像素格式**，广泛用于视频捕获和处理。

### YUYV 格式特点

#### 1. 颜色空间组成
- **Y (Luminance)**：亮度分量，表示图像的明暗程度（0-255）
- **U (Cb)**：色度蓝色分量，表示蓝色与黄色的差异
- **V (Cr)**：色度红色分量，表示红色与绿色的差异

#### 2. 采样方式：4:2:2
- **4:2:2** 的含义：
  - 每 4 个像素采样 **4 个 Y**（亮度）值
  - 每 4 个像素采样 **2 个 U**（色度）值
  - 每 4 个像素采样 **2 个 V**（色度）值

这意味着色度信息在水平方向上被压缩了一半，但垂直方向保持完整。

#### 3. 数据排列方式
YUYV 格式中，每 2 个像素占用 4 个字节：

```
像素对 1: [Y0, U0, Y1, V0]
像素对 2: [Y2, U2, Y3, V2]
像素对 3: [Y4, U4, Y5, V4]
...
```

字节顺序：`Y0 U0 Y1 V0 Y2 U2 Y3 V2 Y4 U4 Y5 V4 ...`

**注意**：U 和 V 分量是共享的，每 2 个像素共享一对 UV 值。

#### 4. 存储大小计算
对于 **640x480** 分辨率的图像：
- 总像素数：640 × 480 = **307,200 像素**
- YUYV 格式：每 2 个像素 = 4 字节
- 总大小：307,200 ÷ 2 × 4 = **614,400 字节** (约 **600 KB**)

### 为什么选择 YUYV？

1. **实时性好**：无需压缩/解压，处理速度快
2. **质量高**：未压缩，保持原始画质
3. **兼容性强**：大多数摄像头都支持
4. **处理方便**：可以直接进行 YUV 空间的处理（如亮度调整、色彩校正）

## 三、.raw 文件详解

### 什么是 .raw 文件？

`.raw` 文件是**原始二进制数据文件**，包含：
- ✅ 未压缩的像素数据
- ❌ 没有文件头、元数据或压缩信息
- ❌ 不包含宽度、高度、格式等描述信息

### 文件内容

保存的 `.raw` 文件包含：
1. **纯二进制数据**：直接是摄像头输出的 YUYV 格式字节流
2. **无格式信息**：文件本身不包含宽度、高度、格式等元数据
3. **需要外部工具查看**：不能直接用图片查看器打开

### 为什么保存为 .raw？

- **YUYV/UYVY/YUV420**：未压缩格式 → 保存为 `.raw`
- **MJPEG/JPEG**：压缩格式 → 保存为 `.jpg`（可直接查看）

### 如何查看 .raw 文件？

#### 方法 1: 使用 FFmpeg 转换（推荐）

```bash
# 将 YUYV .raw 文件转换为 PNG
ffmpeg -f rawvideo \
       -pixel_format yuyv422 \
       -video_size 640x480 \
       -i output/frame_000.raw \
       -frames:v 1 \
       output/frame_000.png

# 或转换为 JPEG
ffmpeg -f rawvideo \
       -pixel_format yuyv422 \
       -video_size 640x480 \
       -i output/frame_000.raw \
       -frames:v 1 \
       output/frame_000.jpg
```

#### 方法 2: 批量转换脚本

```bash
#!/bin/bash
# convert_raw.sh

for file in output/frame_*.raw; do
    filename=$(basename "$file" .raw)
    ffmpeg -f rawvideo \
           -pixel_format yuyv422 \
           -video_size 640x480 \
           -i "$file" \
           -frames:v 1 \
           "output/${filename}.png"
done
```

#### 方法 3: 使用 Python 脚本

```python
import numpy as np
from PIL import Image
import cv2

# 读取 .raw 文件
width, height = 640, 480
with open('output/frame_000.raw', 'rb') as f:
    raw_data = f.read()

# 方法 A: 使用 OpenCV（最简单）
yuyv = np.frombuffer(raw_data, dtype=np.uint8).reshape((height, width * 2))
bgr = cv2.cvtColor(yuyv, cv2.COLOR_YUV2BGR_YUYV)
cv2.imwrite('output/frame_000.png', bgr)

# 方法 B: 手动转换（需要 YUV 到 RGB 转换算法）
# ... 更复杂的实现 ...
```

## 四、格式对比表

| 格式 | 压缩 | 文件大小 (640x480) | 质量 | 实时性 | 用途 |
|------|------|-------------------|------|--------|------|
| **YUYV** | ❌ 无 | ~600 KB | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 视频捕获、实时处理 |
| **UYVY** | ❌ 无 | ~600 KB | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 类似 YUYV，字节顺序不同 |
| **YUV420** | ❌ 无 | ~450 KB | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 文件更小，质量略低 |
| **MJPEG** | ✅ 有 | ~50-200 KB | ⭐⭐⭐⭐ | ⭐⭐⭐ | 视频流、存储 |
| **RGB24** | ❌ 无 | ~900 KB | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 图像处理、显示 |

## 五、常见问题

### Q1: 为什么不能直接用图片查看器打开 .raw 文件？
**A**: `.raw` 文件是纯二进制数据，没有文件头信息。图片查看器不知道：
- 图像的宽度和高度
- 像素格式（YUYV、RGB 等）
- 数据排列方式

### Q2: YUYV 和 UYVY 有什么区别？
**A**: 两者数据量相同，只是字节排列顺序不同：
- **YUYV**: `Y U Y V` 字节顺序
- **UYVY**: `U Y V Y` 字节顺序

### Q3: 为什么选择 YUYV 而不是 MJPEG？
**A**: 
- **YUYV**: 未压缩，质量最高，实时处理快，但文件大
- **MJPEG**: 压缩，文件小，可直接查看，但需要解压

如果设备支持，程序会优先选择 YUYV（质量优先），如果不支持则选择 MJPEG。

### Q4: 如何知道 .raw 文件的格式？
**A**: 程序在保存文件时会打印格式信息：
```
[保存] output/frame_000.raw (大小: 614400 字节, 格式: YUYV)
```

### Q5: 640x480 的 YUYV 文件为什么是 614400 字节？
**A**: 
- 640 × 480 = 307,200 像素
- YUYV: 每 2 像素 = 4 字节
- 307,200 ÷ 2 × 4 = 614,400 字节

## 六、代码修改总结

### 修改的文件
1. `src/demos/demo1_uyvy422/main.cpp`
   - 优化打印逻辑，每秒打印一次
   - 添加格式说明注释
   - 改进输出格式

### 新增的文件
1. `YUYV_FORMAT_EXPLANATION.md` - YUYV 格式详细说明
2. `OPTIMIZATION_SUMMARY.md` - 本文档

### 主要改进
- ✅ 打印不再刷屏，每秒更新一次
- ✅ 添加详细的格式说明和注释
- ✅ 提供 .raw 文件查看方法
- ✅ 优化代码可读性



